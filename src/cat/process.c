#include "cat.h"

/**
 * @brief Находит индекс первого аргумента командной строки, не являющегося
 * флагом.
 *
 * Функция проходит через все аргументы командной строки, начиная с первого
 * аргумента после имени программы, и ищет первый аргумент, который не
 * начинается с дефиса ('-'), предполагая, что это начало списка файлов. Это
 * позволяет различать флаги и пути к файлам в аргументах командной строки.
 *
 * @param argc Количество аргументов командной строки, переданных программе.
 * @param argv Массив строк аргументов командной строки.
 * @return Индекс в массиве `argv` первого аргумента, не являющегося флагом.
 *         Если все аргументы являются флагами, возвращает `argc` (индекс после
 * последнего аргумента).
 */
int find_first_file(int argc, char *argv[]) {
  int startFiles = argc;

  for (int i = 1; i < argc; i++) {
    if (argv[i][0] != '-') {
      startFiles = i;

      break;
    }
  }

  return startFiles;
}

/**
 * @brief Обрабатывает входные данные из файла с учетом заданных флагов.
 *
 * Функция последовательно читает символы из файла и применяет к каждому символу
 * серию операций, определенных в структуре флагов. Обработка включает в себя
 * подсчет строк, сокращение последовательных переносов строк и другие операции
 * в зависимости от активных флагов. Функция поддерживает нумерацию строк,
 * визуализацию непечатаемых символов и другие функции, аналогичные поведению
 * команды `cat` в UNIX-подобных системах.
 *
 * @param flag Структура, содержащая флаги, определяющие операции обработки.
 * @param file Указатель на объект FILE, из которого производится чтение
 * символов.
 *
 * @note При каждом чтении символа из файла функция `operation` вызывается для
 * выполнения необходимых операций обработки в соответствии с заданными флагами.
 * Счетчик строк и последовательных переносов строк используется для
 * определенных условий обработки, таких как нумерация строк или сокращение
 * множественных переносов строк.
 */
void process_input(struct options flag, FILE *file) {
  int thisSymbol;
  int previousSymbol = '\n';
  int countLines = 0, consecutiveLineBreaks = 0;

  while ((thisSymbol = getc(file)) != EOF) {
    int buffer = thisSymbol;

    consecutiveLineBreaks =
        previousSymbol == '\n' ? consecutiveLineBreaks + 1 : 0;
    operation(flag, thisSymbol, previousSymbol, &countLines,
              consecutiveLineBreaks);
    previousSymbol = buffer;
  }
}

/**
 * @brief Обрабатывает аргументы командной строки, заданные пользователем, и
 * устанавливает соответствующие флаги.
 *
 * Функция анализирует аргументы командной строки, используя как короткие, так и
 * длинные опции. Она поддерживает различные флаги, такие как '-v', '-b', '-e',
 * '-E', '-n', '-s', '-t', и '-T', каждый из которых активирует определенный
 * режим работы программы. Длинные опции включают в себя '--number-nonblank',
 * '--number', и
 * '--squeeze-blank'. После обработки всех аргументов функция возвращает
 * структуру `options`, в которой установлены флаги, соответствующие введенным
 * опциям.
 *
 * @param argc Количество аргументов командной строки.
 * @param argv Массив строк, содержащий аргументы командной строки.
 * @return Структура `options`, содержащая булевые флаги, каждый из которых
 * указывает на активацию соответствующей опции.
 *
 * @note В случае обнаружения неизвестных опций программа выводит сообщение об
 * ошибке и завершает работу с кодом 1. Использование функции `getopt_long`
 * позволяет эффективно анализировать как короткие, так и длинные опции,
 * облегчая расширяемость программы.
 */
struct options process_options(int argc, char *argv[]) {
  const char *short_options = "+vbeEnstT";

  const struct option longOptions[] = {
      {"number-nonblank", no_argument, NULL, 'b'},
      {"number", no_argument, NULL, 'n'},
      {"squeeze-blank", no_argument, NULL, 's'},
      {NULL, 0, NULL, 0}};

  struct options flag = {0};

  int rez;
  int optionIndex;

  while ((rez = getopt_long(argc, argv, short_options, longOptions,
                            &optionIndex)) != -1) {
    switch (rez) {
      case 'v': {
        flag.v = true;
        break;
      }
      case 'b': {
        flag.b = true;
        break;
      }
      case 'e': {
        flag.e = true;
        break;
      }
      case 'E': {
        flag.E = true;
        break;
      }
      case 'n': {
        flag.n = true;
        break;
      }
      case 's': {
        flag.s = true;
        break;
      }
      case 't': {
        flag.t = true;
        break;
      }
      case 'T': {
        flag.T = true;
        break;
      }
      case '?':
      default: {
        fprintf(stderr, "Usage: %s [-benstv] [file ...]\n", argv[0]);
        exit(1);
      }
    }
  }

  return flag;
}

/**
 * @brief Обрабатывает файлы, указанные в аргументах командной строки, или
 * стандартный ввод, если файлы не указаны.
 *
 * Функция определяет, были ли указаны файлы в аргументах командной строки. Если
 * файлы не указаны (startFiles равно argc), функция обрабатывает стандартный
 * ввод. В противном случае она последовательно открывает каждый указанный файл,
 * обрабатывает его содержимое с учетом заданных флагов, а затем закрывает файл.
 * В случае ошибки открытия файла выводится сообщение об ошибке.
 *
 * @param flag Структура, содержащая флаги, определяющие режим обработки.
 * @param argc Количество аргументов командной строки.
 * @param argv Массив строк аргументов командной строки.
 * @param startFiles Индекс в массиве argv, с которого начинаются пути к файлам
 * для обработки.
 *
 * @note Важно проверять доступность файла для чтения перед его обработкой. В
 * случае, если файл недоступен, пользователю выводится соответствующее
 * сообщение об ошибке.
 */
void process_files(struct options flag, int argc, char *argv[],
                   int startFiles) {
  if (startFiles == argc) {
    process_input(flag, stdin);
  } else {
    for (int i = startFiles; i < argc; i++) {
      FILE *file = fopen(argv[i], "r");

      if (file == NULL) {
        fprintf(stderr, "cat: %s: No such file or directory\n", argv[i]);
      } else {
        process_input(flag, file);
        fclose(file);
      }
    }
  }
}
