/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "tests_check/_unittests.check" instead.
 */

#include <check.h>

#include "cat.h"

/** @cond */
int s21_cat(int argc, char* argv[]) {
  struct options flag = process_options(argc, argv);
  int startFiles = find_first_file(argc, argv);

  process_files(flag, argc, argv, startFiles);

  return 0;
}
/** @endcond */

/**
 * @brief Клонирует строку.
 *
 * Функция выделяет память под новую строку того же размера, что и s, копирует в
 * неё содержимое s, включая терминальный нулевой символ, и возвращает указатель
 * на новую строку.
 * @param s Указатель на строку, которую необходимо склонировать.
 * @return Указатель на новую строку в случае успеха или NULL, если не удалось
 * выделить память.
 */
char* s21_strdup(const char* s) {
  size_t len = strlen(s) + 1;
  char* new = malloc(len);
  if (new == NULL) return NULL;
  memcpy(new, s, len);
  return new;
}

/**
 * @brief Тестирует поведение функции s21_cat по сравнению с оригинальной
 * утилитой cat UNIX.
 *
 * Функция выполняет запуск кастомной реализации команды cat (s21_cat) и
 * стандартной команды cat с переданными флагами, затем сравнивает вывод обеих
 * команд, используя утилиту diff. Это позволяет проверить корректность работы
 * реализации s21_cat на соответствие стандартному поведению cat.
 * @param flags Строка, содержащая флаги, которые будут использованы при вызове
 * s21_cat и оригинального cat. Флаги должны быть представлены в формате строки,
 * разделенной пробелами, например, "-n -E". Каждый флаг обрабатывается и
 * добавляется в массив аргументов командной строки отдельно.
 *
 * Последовательность действий включает в себя:
 * - Разделение строки флагов на отдельные элементы и формирование аргументов
 * командной строки.
 * - Перенаправление стандартного вывода во временный файл и выполнение s21_cat.
 * - Выполнение оригинального cat с теми же флагами и перенаправление его вывода
 * в другой временный файл.
 * - Сравнение содержимого обоих временных файлов с помощью diff.
 * - Вывод сообщения об ошибке, если содержимое файлов различается.
 * - Удаление временных файлов после сравнения.
 *
 * @note Для корректной работы функции необходима реализация функции s21_cat и
 * доступность системных вызовов cat и diff.
 */
void test_cat(const char* flags) {
  const char* resultS21 = "temp_s21.txt";
  const char* resultOrig = "temp_orig.txt";
  const char* testFile = "./tests_check/files/ascii.txt";

  // Подготовка аргументов командной строки с учетом раздельных флагов
  char* argv[64];
  int argc = 1;
  argv[0] = "./s21_cat";

  // Разделение строки flags на отдельные флаги и добавление их в argv
  // Создаем копию строки флагов, так как strtok модифицирует исходную строку
  char* flagsCopy = s21_strdup(flags);
  char* token = strtok(flagsCopy, " ");
  while (token != NULL) {
    argv[argc++] = token;
    token = strtok(NULL, " ");
  }

  // Добавление имени файла как последнего аргумента
  argv[argc++] = (char*)testFile;
  // NULL-терминатор для массива аргументов
  argv[argc] = NULL;

  // Перенаправление stdout в файл для s21_cat
  (void)freopen(resultS21, "w", stdout);
  s21_cat(argc, argv);
  fclose(stdout);
  free(flagsCopy);

  // Оригинальный cat
  char cmd_orig[1024];
  snprintf(cmd_orig, sizeof(cmd_orig), "cat %s %s > %s", flags, testFile,
           resultOrig);
  system(cmd_orig);

  // Использование утилиты diff для сравнения файлов
  char cmd_diff[1024];
  snprintf(cmd_diff, sizeof(cmd_diff), "diff %s %s", resultS21, resultOrig);
  int diff_result = system(cmd_diff);
  ck_assert_msg(
      diff_result == 0,
      "Outputs of s21_cat with flags '%s' and original cat are different",
      flags);

  // Удаление временных файлов
  unlink(resultS21);
  unlink(resultOrig);
}

START_TEST(cat1) { test_cat(""); }
END_TEST

START_TEST(cat2) {
  // Тестирование с комбинированными флагами "-benstv" без пробелов.
  // Проверяет способность программы обрабатывать несколько флагов, заданных
  // слитно.
  test_cat("-benstv");
}
END_TEST

START_TEST(cat3) {
  // Тест с аналогичными флагами "-bnvste", но в другом порядке.
  // Это должно продемонстрировать, что порядок флагов не влияет на результат.
  test_cat("-bnvste");
}
END_TEST

START_TEST(cat4) {
  // Проверка работы программы с флагами "-b -e -n -s -t -v", указанными через
  // пробелы. Тест на обработку разделенных пробелами флагов.
  test_cat("-b -e -n -s -t -v");
}
END_TEST

START_TEST(cat5) {
  // Тестирование флага "-t", который влияет на отображение табуляции.
  test_cat("-t");
}
END_TEST

START_TEST(cat6) {
  // Проверка флага "-n" для нумерации всех строк вывода.
  // Все строки должны быть пронумерованы последовательно с начала файла.
  test_cat("-n");
}
END_TEST

START_TEST(cat7) {
  // Тестирование флага "-b", который нумерует только непустые строки.
  // Пустые строки должны оставаться без номеров.
  test_cat("-b");
}
END_TEST

START_TEST(cat8) {
  // Проверка флага "-s", предназначенного для сжатия нескольких подряд идущих
  // пустых строк в одну.
  test_cat("-s");
}
END_TEST

START_TEST(cat9) {
  // Тестирование флага "-v" для визуализации непечатаемых символов, кроме
  // пробелов и табуляции.
  test_cat("-v");
}
END_TEST

START_TEST(cat10) {
  // Проверка флага "-e", который добавляет символ '$' в конец каждой строки.
  test_cat("-e");
}
END_TEST

START_TEST(cat11) {
  // Тест с комбинацией флагов "-n -b", указанных через пробел.
  // Проверяется приоритет и взаимодействие флагов нумерации строк.
  test_cat("-n -b");
}
END_TEST

START_TEST(cat12) {
  // Тестирование с комбинированными флагами "-nb" без пробелов.
  // Должно демонстрировать идентичное поведение с предыдущим тестом.
  test_cat("-nb");
}
END_TEST

START_TEST(cat13) {
  // Проверка комбинации флагов "-s -n -e", заданных через пробел.
  // Ожидается сжатие пустых строк, нумерация всех строк и добавление '$'.
  test_cat("-s -n -e");
}
END_TEST

START_TEST(cat14) {
  // Тест с флагами "-sne", заданными слитно.
  // Должен проверить, что комбинирование флагов в одной строке работает
  // корректно.
  test_cat("-sne");
}
END_TEST

START_TEST(cat_linux1) {
  // Проверка визуализации табуляций как "^I".
  test_cat("-T");
}
END_TEST

START_TEST(cat_linux2) {
  // Добавление "$" в конец каждой строки.
  test_cat("-E");
}
END_TEST

START_TEST(cat_linux3) {
  // Визуализация непечатаемых и табуляций.
  test_cat("-vT");
}
END_TEST

START_TEST(cat_linux4) {
  // Нумерация всех строк файла.
  test_cat("--number");
}
END_TEST

START_TEST(cat_linux5) {
  // Сжатие множественных пустых строк.
  test_cat("--squeeze-blank");
}
END_TEST

START_TEST(cat_linux6) {
  // Нумерация только непустых строк.
  test_cat("--number-nonblank");
}
END_TEST

START_TEST(coverage1) {
  // Функция option_s корректно обрабатывает последовательности переносов строк.
  char* pThisSymbol = "\n";
  char previous_simbol = '\n';
  int consecutiveLineBreaks = 2;
  int pIsItNull = 0;
  option_s(pThisSymbol, previous_simbol, consecutiveLineBreaks, &pIsItNull);
  ck_assert_int_eq(pIsItNull, 1);
}
END_TEST

int main(void) {
  Suite* s1 = suite_create("cat");
  TCase* tc1_1 = tcase_create("cat");
  Suite* s2 = suite_create("cat_linux");
  TCase* tc2_1 = tcase_create("cat_linux");
  Suite* s3 = suite_create("coverage");
  TCase* tc3_1 = tcase_create("coverage");
  SRunner* sr = srunner_create(s1);
  int nf;

  suite_add_tcase(s1, tc1_1);
  tcase_add_test(tc1_1, cat1);
  tcase_add_test(tc1_1, cat2);
  tcase_add_test(tc1_1, cat3);
  tcase_add_test(tc1_1, cat4);
  tcase_add_test(tc1_1, cat5);
  tcase_add_test(tc1_1, cat6);
  tcase_add_test(tc1_1, cat7);
  tcase_add_test(tc1_1, cat8);
  tcase_add_test(tc1_1, cat9);
  tcase_add_test(tc1_1, cat10);
  tcase_add_test(tc1_1, cat11);
  tcase_add_test(tc1_1, cat12);
  tcase_add_test(tc1_1, cat13);
  tcase_add_test(tc1_1, cat14);
  suite_add_tcase(s2, tc2_1);
  tcase_add_test(tc2_1, cat_linux1);
  tcase_add_test(tc2_1, cat_linux2);
  tcase_add_test(tc2_1, cat_linux3);
  tcase_add_test(tc2_1, cat_linux4);
  tcase_add_test(tc2_1, cat_linux5);
  tcase_add_test(tc2_1, cat_linux6);
  suite_add_tcase(s3, tc3_1);
  tcase_add_test(tc3_1, coverage1);

  srunner_add_suite(sr, s2);
  srunner_add_suite(sr, s3);

  srunner_run_all(sr, CK_ENV);
  nf = srunner_ntests_failed(sr);
  srunner_free(sr);

  return nf == 0 ? 0 : 1;
}
